var region = Map.getBounds(true)

// Load Sentinel 2 TOA image.
var images = ee.ImageCollection('COPERNICUS/S2').filterDate('2015-07-01','2020-03-25').filterBounds(poly);

function addQualityScore(images, region, options) {
  var scorePercentile = (options && options.percentile) || 75
  var scale = (options && options.scale) || 500
  var mask = (options && options.mask) || null
  var qualityBand = (options && options.qualityBand) || 'B3'// ?????

  return images
    .map(function(i) { 
      var score = i.select(qualityBand) //.where(i.select('green').gt(0.5), 0.5)

      if(mask) {
        score = score.updateMask(mask)
      }

      score = score        
        .reduceRegion(ee.Reducer.percentile([scorePercentile]), region, scale).values().get(0)

      // var score = i.select('green').add(i.select('blue'))
      //  .reduceRegion(ee.Reducer.percentile([scorePercentile]), g, scale).values().get(0)

      // var cloudScore = computeCloudScore(i)
      // var score = cloudScore.gt(cloudThreshold)
      //   .reduceRegion(ee.Reducer.sum(), g, scale).values().get(0)

      return i.set({ quality_score: score })
    })
}



function getMostlyCleanImages(images, region, options) {
  region = ee.Geometry(region)
  
  var scale = (options && options.scale) || 500
  var p = (options && options.percentile) || 85

  // http://www.earthenv.org/cloud
  var modisClouds = ee.Image('users/gena/MODCF_meanannual')
  
  var cloudFrequency = modisClouds.divide(10000).reduceRegion(
    ee.Reducer.percentile([p]), 
    region.buffer(10000, scale*10), scale*10).values().get(0)
    
  //print('Cloud frequency (over AOI):', cloudFrequency)
  
  // decrease cloudFrequency, include some more partially-cloudy images then clip based on a quality metric
  // also assume inter-annual variability of the cloud cover
  cloudFrequency = ee.Number(cloudFrequency).subtract(0.15).max(0.0)
  
  if(options && options.cloudFrequencyThresholdDelta) {
    cloudFrequency = cloudFrequency.add(options.cloudFrequencyThresholdDelta)
  }
    


  var images = images
    .filterBounds(region)

  var size = images.size()
  
  images = addQualityScore(images, region, options)
    .filter(ee.Filter.gt('quality_score', 0)) // sometimes null?!

  /*
  var scoreMin = 0.01
  var scoreMax = images.reduceColumns(ee.Reducer.percentile([ee.Number(1).subtract(cloudFrequency).multiply(100)]), ['score']).values().get(0)
  
  if(debug) {
    printChart('Quality score:', ui.Chart.feature.histogram(images, 'score', 200))
    print('scoreMax:', scoreMax)
    print('size, all: ', size)
  }
  
  // filter by quality score
  // images = images
  //   .filter(ee.Filter.and(ee.Filter.gte('score', scoreMin), ee.Filter.lte('score', scoreMax)))
  */
  
  // clip collection
  images = images.sort('quality_score')
    .limit(images.size().multiply(ee.Number(1).subtract(cloudFrequency)).toInt())
    
  // remove too dark images
  //images = images.sort('quality_score', false)
    //.limit(images.size().multiply(0.99).toInt())
  
  //print('size, filtered: ', images.size())      

  return images
    //.set({scoreMax: scoreMax})
}

var myCollection = getMostlyCleanImages(images, region, {
   cloudFrequencyThresholdDelta: 0.15 })

var listOfImages = myCollection.toList(myCollection.size());
var first =ee.Image(listOfImages.get(0));

print(listOfImages.size())

//print(dataset.first().propertyNames());

var rgbVis = {
  min: 0.0,
  max: 0.3,
  bands: ['B4', 'B3', 'B2'],
};
Map.addLayer(myCollection.median(), rgbVis, '');

//var ndwi = image.mean().normalizedDifference(['green', 'nir'])
var mndwi = first.normalizedDifference(['B3', 'B11'])

var new_image=ee.Image(mndwi)

var new_image = new_image.mask(new_image)

var ndwiViz = {min: 0.5, max: 1, palette: ['00FFFF', '0000FF']};
Map.addLayer(new_image, ndwiViz, 'MNDWI', false);


function edges(img) {
    var canny = ee.Algorithms.CannyEdgeDetector(img, 0.99, 0);
    return canny.mask(canny);
}

var water_edges = edges(new_image)
Map.addLayer(water_edges, {min: 0, max: 1, palette: 'FF0000'}, 'edges');

var bufferSize = 30 // in meters
var edgeBuffer = water_edges.focal_max(bufferSize, 'square', 'meters'); 
Map.addLayer(edgeBuffer.updateMask(edgeBuffer),{},'Buffered Edges');
